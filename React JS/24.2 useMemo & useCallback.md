# ðŸ“š **Lecture 24.2 - React Hooks: `useMemo` & `useCallback`**

---

## **1. `useMemo` Hook**

### **Definition**

`useMemo` is a React hook that **memoizes** (remembers) the result of a calculation **so React doesnâ€™t re-compute it every render** unless its dependencies change.

ðŸ“Œ Think of it like a **"cached value"** in your component.

---

### **When to Use**

* To **optimize performance** when a calculation is expensive (takes time).
* To prevent **unnecessary re-calculations** of derived data.
* When passing computed values to **child components** so they donâ€™t re-render unnecessarily.

---

### **Syntax**

```jsx
const memoizedValue = useMemo(() => {
  // Some expensive computation
  return result;
}, [dependency1, dependency2]);
```

---

### **Industry-Level Example**

Imagine you have **a huge product list** and need to calculate filtered results every time the user types in a search bar.
Without `useMemo`, the filtering runs **on every re-render** â€” even if the search hasnâ€™t changed.

```jsx
import React, { useState, useMemo } from "react";

function ProductList({ products }) {
  const [search, setSearch] = useState("");

  // âœ… useMemo caches the filtered products until search changes
  const filteredProducts = useMemo(() => {
    console.log("Filtering products..."); // Will run only when `search` changes
    return products.filter((product) =>
      product.name.toLowerCase().includes(search.toLowerCase())
    );
  }, [search, products]);

  return (
    <div>
      <input
        type="text"
        placeholder="Search..."
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      <ul>
        {filteredProducts.map((p) => (
          <li key={p.id}>{p.name}</li>
        ))}
      </ul>
    </div>
  );
}

export default ProductList;
```

---

## **2. `useCallback` Hook**

### **Definition**

`useCallback` is a React hook that **memoizes a function** so that its reference **does not change between renders** unless dependencies change.

ðŸ“Œ Think of it like **"cached function"** in your component.

---

### **When to Use**

* To prevent unnecessary re-renders of **child components** that depend on a function prop.
* To avoid creating a **new function every render**, especially in performance-sensitive components.

---

### **Syntax**

```jsx
const memoizedFunction = useCallback(() => {
  // Function logic
}, [dependency1, dependency2]);
```

---

### **Industry-Level Example**

Imagine a **child component** that only re-renders when its props change.
If we pass a normal function as a prop, it **gets recreated every render** â€” triggering a re-render of the child unnecessarily.
`useCallback` fixes that.

```jsx
import React, { useState, useCallback, memo } from "react";

const Button = memo(({ onClick, label }) => {
  console.log(`Rendering button: ${label}`);
  return <button onClick={onClick}>{label}</button>;
});

function Counter() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => {
    setCount((prev) => prev + 1);
  }, []);

  return (
    <div>
      <h2>Count: {count}</h2>
      <Button onClick={increment} label="Increment" />
    </div>
  );
}

export default Counter;
```

âœ… Here, the `Button` component wonâ€™t re-render unless `increment` changes â€” which it wonâ€™t because of `useCallback`.

---

## **3. `useMemo` vs `useCallback`**

| Feature             | `useMemo`                            | `useCallback`                            |
| ------------------- | ------------------------------------ | ---------------------------------------- |
| **What it returns** | **Memoized value**                   | **Memoized function**                    |
| **Use case**        | Avoid recalculating expensive values | Avoid recreating functions unnecessarily |
| **Example**         | Caching a sorted list                | Passing stable function to child         |
| **Type**            | Returns **data**                     | Returns **function**                     |

---

## **4. Which One Should I Use?**

* If you want to **memoize a value** â†’ `useMemo`
* If you want to **memoize a function** â†’ `useCallback`
* Both are **performance optimizations** â€” donâ€™t use them **everywhere**.
  Use only if you **see unnecessary re-renders** or **heavy computations**.

---

## **5. Simple Practical Example (Both Together)**

```jsx
import React, { useState, useMemo, useCallback } from "react";

function ShoppingCart() {
  const [cart, setCart] = useState([]);
  const [product, setProduct] = useState("");

  // ðŸ§  Memoized total price calculation
  const totalPrice = useMemo(() => {
    console.log("Calculating total...");
    return cart.reduce((sum, item) => sum + item.price, 0);
  }, [cart]);

  // âš¡ Memoized function to add item
  const addProduct = useCallback(() => {
    if (product.trim()) {
      setCart((prev) => [...prev, { name: product, price: Math.random() * 100 }]);
      setProduct("");
    }
  }, [product]);

  return (
    <div>
      <h2>Total Price: ${totalPrice.toFixed(2)}</h2>
      <input value={product} onChange={(e) => setProduct(e.target.value)} />
      <button onClick={addProduct}>Add</button>
      <ul>
        {cart.map((item, idx) => (
          <li key={idx}>{item.name} - ${item.price.toFixed(2)}</li>
        ))}
      </ul>
    </div>
  );
}

export default ShoppingCart;
```

âœ… Here:

* `useMemo` â†’ avoids recalculating total price unless `cart` changes.
* `useCallback` â†’ avoids creating a new `addProduct` function every render.
