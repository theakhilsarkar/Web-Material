# ðŸ“˜ `createAsyncThunk` in Redux Toolkit

## ðŸ”¹ Definition

`createAsyncThunk` is a utility provided by **Redux Toolkit** to handle **asynchronous operations** (like API calls) in Redux.
It automatically generates **action creators** for:

* **pending** â†’ when the request starts
* **fulfilled** â†’ when the request succeeds
* **rejected** â†’ when the request fails

This helps avoid writing extra boilerplate for async actions.

---

## ðŸ”¹ Why Use `createAsyncThunk`?

1. **Simplifies async code** â€“ no need to manually write pending/fulfilled/rejected actions.
2. **Handles loading/error states** automatically.
3. **Keeps Redux state predictable** when working with APIs.
4. **Standardized pattern** â€“ easy for teams to understand.

---

## ðŸ”¹ Real-World Use Cases

* Fetching data from REST APIs (books, users, posts, etc.).
* Sending POST requests to create new resources.
* Updating or deleting data on a server.
* Handling authentication requests (login, register).

---

## ðŸ”¹ Practical Example (Using JSONPlaceholder API)

### Step 1: Install required packages

```bash
npm install @reduxjs/toolkit react-redux axios
```

---

### Step 2: Create a Slice with `createAsyncThunk`

```js
// features/posts/postSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import axios from "axios";

// âœ… Async Thunk for fetching posts
export const fetchPosts = createAsyncThunk("posts/fetchPosts", async () => {
  const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
  return response.data; // automatically passed to fulfilled action
});

// Slice
const postSlice = createSlice({
  name: "posts",
  initialState: {
    posts: [],
    status: "idle", // idle | loading | succeeded | failed
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.posts = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.error.message;
      });
  },
});

export default postSlice.reducer;
```

---

### Step 3: Setup Store

```js
// store.js
import { configureStore } from "@reduxjs/toolkit";
import postReducer from "./features/posts/postSlice";

export const store = configureStore({
  reducer: {
    posts: postReducer,
  },
});
```

---

### Step 4: Provide Store to App

```jsx
// main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import { Provider } from "react-redux";
import { store } from "./store";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root")).render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

---

### Step 5: Use `fetchPosts` in Component

```jsx
// App.jsx
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { fetchPosts } from "./features/posts/postSlice";

function App() {
  const dispatch = useDispatch();
  const { posts, status, error } = useSelector((state) => state.posts);

  useEffect(() => {
    dispatch(fetchPosts());
  }, [dispatch]);

  return (
    <div>
      <h1>ðŸ“Œ Posts from JSONPlaceholder</h1>
      {status === "loading" && <p>Loading...</p>}
      {status === "succeeded" && (
        <ul>
          {posts.slice(0, 5).map((post) => (
            <li key={post.id}>
              <b>{post.title}</b>
            </li>
          ))}
        </ul>
      )}
      {status === "failed" && <p style={{ color: "red" }}>Error: {error}</p>}
    </div>
  );
}

export default App;
```

---

## ðŸ”¹ Output Behavior

1. On app load â†’ Dispatch `fetchPosts`.
2. While fetching â†’ `status = "loading"` â†’ show *Loadingâ€¦*.
3. If success â†’ `status = "succeeded"` â†’ display post titles.
4. If failed â†’ `status = "failed"` â†’ show error.

---

## ðŸ”¹ Importance in Projects

* Makes **data fetching predictable**.
* Reduces **boilerplate code** (no need to manually manage loading/error states).
* Ideal for **team projects** where async state handling must be consistent.
* Scales well for **large apps** (Library Management, E-commerce, Social Media).
